//=========================================================
//SChain
//链表类
//
//编写：方寸
//
//说明：链表索引从0开始
//
//日期：2013-8-14
//=========================================================
#ifndef _S_CHAIN_H_
#define	_S_CHAIN_H_

template<class T>
class SChain
{
	//Data
	private:
		struct Node
		{
			T Data;
			Node *pNext;
		};
		Node *m_pHead;//链表头结点
		int m_nCount;//链表中数据数
	//Function
	public:
		//=========================================================
		//函数：SChain
		//说明：构造函数
		//输入：
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		SChain()
		{
			m_pHead=new Node;

			if(!m_pHead)
			{
				printf("头结点内存申请失败！");
			}

			m_pHead->pNext=NULL;
			m_nCount=0;
		}
		//=========================================================
		//函数：~SChain
		//说明：解析函数
		//输入：
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		~SChain()
		{
			Clear();
			if(m_pHead)
				delete m_pHead;
		}
		//=========================================================
		//函数：=(SChain)
		//说明：运算符重载
		//输入：
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		void operator =(SChain &chain)
		{
			int i;

			Clear();
			for(i=0;i<chain.GetCount();i++)
			{
				Add(*chain.Get(i));
			}
		}
		//=========================================================
		//函数：Clear
		//说明：清空链表
		//输入：
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		void Clear()
		{
			Node *p;

			while(m_pHead->pNext)
			{
				p=m_pHead->pNext;
				m_pHead->pNext=p->pNext;
				delete p;
			}

			m_nCount=0;
		}

		//=========================================================
		//函数：DeleteHead
		//说明：删除链表头部元素
		//输入：
		//输出：
		//返回：true：删除成功,false：删除失败
		//日期：2013-8-14
		//备注：
		//=========================================================
		bool DeleteHead()
		{
			return Delete(0);
		}

		//=========================================================
		//函数：Delete
		//说明：删除链表中的一个元素
		//输入：nIndex：要删除的元素位置索引（从0开始）
		//输出：
		//返回：true：删除成功,false：删除失败
		//日期：2013-8-14
		//备注：
		//=========================================================
		bool Delete(int nIndex)
		{
			int i;
			Node *p;
			Node *pDelete;
 
			if(nIndex<0 || nIndex>=GetCount())
				return false;
			
			i=0;
			p=m_pHead;
			while(i<nIndex)
			{
				p=p->pNext;
				i++;
			}

			pDelete=p->pNext;
			p->pNext=pDelete->pNext;

			delete pDelete;

			m_nCount--;

			return true;
		}
		
		//=========================================================
		//函数：AddHead
		//说明：向链表中头加入一个元素
		//输入：
		//输出：
		//返回：true：插入成功,false：插入失败
		//日期：2013-8-14
		//备注：
		//=========================================================
		bool AddHead(T &Item)
		{
			return Insert(0,Item);
		}

		//=========================================================
		//函数：Add
		//说明：向链表中添加一个元素
		//输入：
		//输出：
		//返回：true：插入成功,false：插入失败
		//日期：2013-8-14
		//备注：
		//=========================================================
		bool Add(T &Item)
		{
			return Insert(GetCount(),Item);
		}
		//=========================================================
		//函数：Insert
		//说明：向链表中插入一个元素
		//输入：nIndex：要插入到的位置索引（从0开始），
		//			Item：要插入的数据（Copy）
		//输出：
		//返回：true：插入成功,false：插入失败
		//日期：2013-8-14
		//备注：
		//=========================================================
		bool Insert(int nIndex,T &Item)
		{
			int i;
			Node *pNew;
			Node *p;

			if(nIndex<0 || nIndex>GetCount())
				return false;

			p=m_pHead;
			i=0;
			while(i<nIndex)
			{
				p=p->pNext;
				i++;
			}
			
			pNew=new Node;
			pNew->Data=Item;
			pNew->pNext=p->pNext;
			p->pNext=pNew;

			m_nCount++;

			return true;
		}

		//=========================================================
		//函数：GetHead
		//说明：获取链表头部元素
		//输入：
		//输出：
		//返回：
		//日期：2013-10-15
		//备注：
		//=========================================================
		T *GetHead()
		{
			return Get(0);
		}

		//=========================================================
		//函数：Get
		//说明：返回链表中指定元素（链表索引从0开始）
		//输入：Index：要返回的指定元素索引
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		T *Get(int Index)
		{
			int i;
			Node *p;

			if(Index<0 || Index>=GetCount())
				return NULL;
			
			p=m_pHead->pNext;
			for(i=0;i<Index;i++)
				p=p->pNext;

			return &p->Data;
		}

		//=========================================================
		//函数：GetCount
		//说明：返回链表中数据数
		//输入：
		//输出：
		//返回：
		//日期：2013-8-14
		//备注：
		//=========================================================
		int GetCount()
		{
			return m_nCount;
		}
};


#endif
